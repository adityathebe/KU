# 4. Informed Search and Exploration

1. Searching
  - Search Problem
  - Search methods
    - Uninformed (blind)
    - Heuristically informed - uses domain-dependent (heuristic) information to search the space more efficiently
2. Measuring Problem Solving Performance
  - Completeness
  - Time Complexity
  - Space Complexity
  - Optimality/Admissibility
3. Blind Search Methods
  - Breadth First Search
  - [Uniform Cost Search](https://www.youtube.com/watch?v=dRMvK76xQJI)
    - [UCS vs Dijkstra Algorithm](https://stackoverflow.com/a/39396812)
  - Depth First Search
  - Depth Limited Search
  - Iterative Deepening Depth First Search
4. Heuristic Search
  - Admissible Heuristics
  - Best First Search
  - A* Search

## Searching for solution

A node is a data structure with 5 components
- state
- parent node
- action
- path-cost
- depth

**Fringe** is the collection of nodes that have been generated by not yet expanded. Each element of the fringe is a leaf node.

## Breadth First Search

- Every node that is generated must remain in memory, because it is either part of the fring or is an ancestor of a fringe node. The space complexity is therefore the same as time complexity (plus one for the root node)

## Uniform Cost Search

- Unlike BFS, which expands the shallowest node, UCS expands the node `n` with the lowest path cost
- Only cares about the total cost and not the number of steps a path has
- **Completness** & **Optimality** can be guaranteed if every step is greater than zero
- Since UCS is guided by path costs rather than depths, its complexity cannot easily be characterized in terms of b and d,

## Depth Limited Search

- alleviates unbounded tress problem in DFS by limiting the depth of search. The nodes at depth l are treated as if they have no sucessors.
- Introduces **Incompleteness** if chosen depth (l) < d

## Iterative deepening depth-first search

- gradually increases the depth limit until a goal is found
- combines the benefits of DFS and BFS
- like DFS its memory requirements are very modest O(bd)
- like BFS it is complete when the branching factor is finite and optimal

## Heuristic Search

Blind Search is slow and resource intensive

#### Ways of using 
1. Decide which node to expand next using evaluation function
2. Decide which successor to generate instead of blinding generating all possible successors at a time
3. Decide which nodes should be discarded or pruned

### Best-First Search

Use an evaluation function `f(n)` that gives an indication of which node to expand next 

### A* Search
- Evaluation function combines `h(n)` and `g(n)`
- optimal if `h(n)` is admissible heuristic (never overestimating)
